\documentclass[spanish,draft,12pt,headsepline,footsepline,paper=letter]{scrreprt}
\pagestyle{headings}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\def\spanishoptions{es-noquoting,es-nolists,mexico-com}
\usepackage[spanish]{babel}

\usepackage{makeidx}
\makeindex

\usepackage[nonumberlist]{glossaries}
\makeglossaries

\usepackage[final]{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\graphicspath{{media/}}
\usepackage{rotating}

\usepackage{scrhack}

\usepackage{natbib}
\usepackage{amsmath,amssymb, bm}
\usepackage{enumerate}
\usepackage{ragged2e}
\usepackage{nameref}

\usepackage{setspace}
\onehalfspacing
\frenchspacing
\recalctypearea

\usepackage{marginnote}
% \usepackage{hyperref}

\setlength{\parindent}{0.25in}
\renewenvironment{quotation}{\list{}{\leftmargin=0.25in}\item[]}{\endlist}
\newcommand{\BigO}{\ensuremath{\mathcal{O}}}% big-O notation/symbol
\addto\captionsspanish{
  \renewcommand\bibname{Referencias}
}

\newglossaryentry{asignatura} {
	   name = asignatura,
    description = {Materia que se enseña en un curso y que forma parte de un programa de estudios}}
\newglossaryentry{aula} {
	   name = aula,
    description = {Sala de un centro de enseñanza donde acuden alumnos}}
\newglossaryentry{complecion} {
    name        = compleción,
    description = {Calidad o condición de completo:aquella destrucción no se llevaba a efecto con el rigor y la compleción debidos}}
\newglossaryentry{clase} {
           name = clase,
    description = {Conjunto de escolares o estudiantes de un mismo nivel o que estudian la misma asignatura, y que asisten juntos a las lecciones correspondientes}}
\newglossaryentry{curriculo} {
           name = currículo,
    description = {Plan de estudios}}
\newglossaryentry{curso} {
           name = curso,
    description = {Conjunto de lecciones o clases sobre una materia que está estructurada y sigue un programa, especialmente dentro de un plan de estudios}}
\newglossaryentry{escuela} {
           name = escuela,
    description = {Institución o establecimiento destinados a enseñar determinadas materias especializadas}}
\newglossaryentry{leccion} {
           name = lección,
    description = {Sesión docente en la que el profesor de una materia imparte un conjunto articulado de conocimientos}}
\newglossaryentry{turno} {
           name = turno,
    description = {Conjunto de trabajadores que desempeñan su actividad al mismo tiempo, según un orden establecido previamente}}
\newglossaryentry{revision bibliografica}{
          name = revisión bibliográfica,
   description = {La revisión bibliográfica comprende todas las actividades relacionadas con la búsqueda de información escrita sobre un tema acotado previamente y sobre el cual, se reúne y discute críticamente, toda la información recuperada y utilizada}}
\newglossaryentry{procedimental}{
          name = procedimental,
   description = {Del procedimiento o relacionado con él:la exigencia de total y absoluta formalidad procedimental}}
\newglossaryentry{precedencia}{
          name = precedencia,
   description = {Circunstancia de preceder a una cosa o persona en el tiempo o en el espacio o de tener más importancia que otra persona o cosa: la precedencia de un acontecimiento sobre otro}}
\newglossaryentry{patron}{
          name = patrón,
   description = {Cosa que se toma como modelo o punto de referencia para medir o valorar otras de la misma especie:patrón de conducta; la alegría es imponderable, pues no existe ningún patrón para medirla}}

\newglossaryentry{matriz}{
          name = matriz,
   description = {Conjunto de números o signos algebraicos distribuidos en filas y columnas y dispuestos en forma de rectángulo sobre el que se definen ciertas operaciones}}
\newglossaryentry{heuristica}{
          name = heurística,
   description = {En algunas ciencias, manera de buscar la solución de un problema mediante métodos no rigurosos, como por tanteo, reglas empíricas, etc.}}
\newglossaryentry{factible}{
          name = factible,
   description = {Que se puede hacer}}
\newacronym{acro_cpm} {CPM}{\textit{Critical Path Method}; Método de la ruta crítica}


\begin{document}

\title{Calendarización en instituciones educacionales}
\author{Héctor Arciga}
\date{\today}

\maketitle

\begin{abstract}
Abstract
\end{abstract}

\begin{spacing}{1}
\tableofcontents
\glsaddall
\printglossaries
\listoffigures
\listoftables
\end{spacing}

\chapter{Introducción}

\section{Antecedentes y motivación}

En la actualidad la formación del individuo ha sido arrebatada por el Estado bajo falsas pretensiones. Es mi convicción que la esencia de una sociedad la define el actuar de sus individuos y es derecho divino de la familia transmitir sus propios valores, creencias e historia a sus futuras generaciones. El sistema educativo moderno apuesta por la transformación social, a conveniencia de los intereses de terceros, erosionando día a día la cultura propia de la comunidad. La institucionalización de la educación tiene un impacto profundo en el tejido social; su rol en la transformación social es cada vez más aparente conforme avanza la globalización, estandarizando los procesos educacionales. Es necesario crear alternativas para quienes deseamos que la educación sea en servicio del individuo, su familia y comunidad; para ello es fundamental contar con herramientas que permitan experimentar ampliamente con la estructura y procesos de la institución educativa, facilitando a la vez su evaluación, de acuerdo a los intereses propios de la institución. 

El sistema educativo es extremadamente complejo, sin embargo toda institución cuenta con los mismos elementos básicos: alumnos, profesores, aulas, clases, asignaturas y lecciones. La conformación de estos en un programa educacional establece dinámicas de vasto alcance trastocando aspectos operacionales en ámbitos pedagógicos, financieros, laborales, regulatorios y sociales.

Mucho se ha discutido acerca de cómo mejorar el desempeño de las instituciones educativas, predominan cavilaciones que sugieren la inversión en infraestructura; la capacitación continua de los docentes; el aprovisionamiento gratuito de útiles escolares, uniformes, alimentos; la  inclusión de nuevas tecnologías informáticas en el proceso de enseñanza; mejoras en las condiciones laborales del magisterio; entre muchas otras. 

\section{Objetivos de la investigación}

Esta tesis investiga la problemática de la elaboración de horarios en instituciones docentes y el impacto potencial de su formulación en distintas métricas de desempeño educacional relevantes para el gestor\index{gestor escolar} escolar.
El fin primordial del trabajo es investigar de qué manera puede el gestor escolar hacer uso de estas técnicas, para la consecución de sus estrategias.
Para poder cumplir con esta finalidad, los siguientes objetivos son considerados:
\begin{enumerate}[1]
\item La investigación de las distintas problemáticas en la planificación de horarios en instituciones docentes.
\item Las distintas formulaciones\index{formulación matemática} matemáticas de los problemas de planificación de horarios.
\item Los algoritmos de solución disponibles para este tipo de modelos matemáticos.
\item Los antecedentes históricos de técnicas de optimación aplicados a partir del surgimiento de los ordenadores.
\item La recopilación de las métricas\index{métricas de desempeño} de desempeño educacional relevantes para los gestores escolares.
\item Una investigación de las restricciones más comunes utilizadas en las formulaciones de los problemas de planificación de horarios.
\end{enumerate}

\section{Descripción de la tesis}

Esta tesis consiste de ocho capítulos. El presente capítulo presenta los antecedentes, motivación y objetivos de la investigación. El resto de la tesis está organizada de la siguiente manera:

El Capítulo 2 presenta una visión general de la problemática así como su clasificación en la literatura.

Los preliminares de la calendarización en general aparecen en el Capítulo 3.

En el Capítulo 4 se detallan los modelos matemáticos y los algoritmos existentes para su solución así como una propuesta de un lenguaje en común para la representación de los problemas.

Las restricciones y funciones objetivo más comunes en la literatura se exponen en el Capítulo 5.

El papel del gestor escolar se discute en el Capítulo 6.

En el Capítulo 7 se hace una exposición del tipo de herramientas existentes para la solución de estos problemas así como un listado de algunas opciones de software encontradas.

Por último, en el Capítulo 8 se presenta un resumen del trabajo de investigación, las contribuciones hechas en el mismo, el trabajo futuro y la diseminación de trabajo.

\chapter{Preliminares}
\label{preliminares}

\section{Introducción}
\label{introduccion_preliminares}

Este capítulo es una revisión bibliográfica enfocada en los aspectos fundamentales del área de investigación.
Introduce conceptos primordiales para el estudio del problema general de programación, los elementos que lo componen, su proceso de elaboración y las definiciones a utilizar a lo largo del trabajo. Además relata los orígenes de las técnicas para la solución de los problemas de programación, las áreas de aplicación de la programación y la teoría detrás de los modelos matemáticos.
El capítulo comprende 5 secciones. La sección \ref{programacion_elementos} introduce los conceptos de programación\index{programación} y programa\index{programa} así como los elementos involucrados en el proceso\index{programación!proceso} de programación, esclarece términos prevalentes en la literatura y establece la definición de conceptos relevantes. La sección \ref{historia_programacion} recuenta los orígenes de la programación, mientras que en la sección \ref{areas_aplicacion} se presentan algunas áreas de aplicación de la programación. Por último, en la sección \ref{teoria_programacion} se expone la teoría detrás de la programación.

\section{La programación y sus elementos} % (fold)
\label{programacion_elementos}

Para \citet{Baker2009}, la palabra programación\index{programación} forma parte del vocabulario diario —aunque no siempre se tenga una idea clara de su significado–. En realidad, no es la programación en sí lo que es un concepto común de la vida cotidiana, son más bien los programas\index{programa}. Un \textbf{programa} es un plan o documento tangible, tal como el programa de salidas de un autobús o un programa de clases. Éste señala cuándo debe suceder algún evento\index{evento}; especifica un plan para el tiempo de ocurrencia de ciertas actividades\index{actividad} y contesta la pregunta: «Si todo va bien, ¿cuándo ocurrirá un evento determinado?».
%
Si se desea conocer la hora en que será servida la cena o el momento en que un autobús saldrá a su destino, el evento\index{evento} de interés es la compleción de una actividad\index{actividad} particular —como lo es la preparación de la cena— o el comienzo de una actividad específica —como el viaje en autobús—. Las respuestas a la pregunta «¿cuándo?» usualmente están relacionadas con información de tiempos\index{tiempo}. La cena está programada para ser servida a las 18:00, el autobús está programado para salir a las 8:00. Sin embargo, una respuesta igualmente útil puede ser dada en términos de secuencia\index{secuencia} en lugar de tiempo: es decir, la cena será servida tan pronto como el platillo principal esté horneado, o el autobús partirá a su destino en cuanto su limpieza y mantenimiento sean completados. Por lo tanto, la pregunta «¿cuándo?» puede ser contestada ya sea con información de secuencia o de tiempos obtenida a partir de un programa \citetext{p.~1}.

\citet{Baker2009} afirman que de manera intuitiva, se puede pensar que la programación\index{programación} es el proceso\index{programación!proceso} de producir un programa\index{programa}, sin embargo rara vez se consideran los detalles que ello conlleva. De hecho, aunque se piense en un programa como algo tangible, el proceso de programación parece no serlo, hasta que es considerado con cierto detenimiento. El problema es comúnmente atacado en dos pasos: \textbf{secuenciación}\index{secuenciación} y \textbf{programación}. En el primer paso, se planifica una secuencia\index{secuencia} o se decide cómo elegir la siguiente tarea. En el segundo paso, se planifica para cada tarea, la hora de inicio y tal vez la hora de compleción.
%
La preparación de una comida o el lavado de ropa son buenos ejemplos de problemas cotidianos de programación\index{programación}. Ambos involucran tareas\index{tarea} a realizar, las tareas\index{tarea} son específicas, y requieren de recursos\index{recurso} determinados: un cocinero y una estufa para la preparación de la comida, y una lavadora y secadora para el lavado de ropa.  Los problemas de programación en el ámbito educacional tienen una estructura similar: consisten de un conjunto de tareas a realizar y de un conjunto de recursos disponibles para llevar a cabo dichas tareas. Dados un conjunto de tareas\index{tarea} y recursos, el problema en general\index{programación!problema general} es determinar los tiempos de inicio de las tareas a la vez que se reconocen las capacidades de los recursos \citetext{p.~2}.

\citet{Baker2009} elaboran explicando que el problema\index{programación!problema} usualmente surge dentro de una jerarquía de toma de decisiones en donde la programación\index{programación} sigue algunas decisiones más básicas, hechas anteriormente. La preparación de una comida, por ejemplo, típicamente requiere una especificación de los elementos en el menú, las recetas de los mismos, e información respecto a cuántas raciones serán necesarias. En el contexto educacional, decisiones análogas se dice forman parte de la \textbf{función administrativa de planificación}\index{administración!función de planificación}. Entre otras cosas, la función de planificación puede describir el diseño del plan de estudios, la tecnología disponible para la educación, los exámenes para evaluar el desempeño y los niveles de aprovechamiento deseados. En síntesis, la función de planificación determina los recursos\index{recurso} disponibles para el logro de los objetivos deseados y las tareas\index{tarea} a ser programadas.
%
En el \textbf{proceso\index{programación!proceso} de programación}, es necesario conocer el tipo y cantidad de cada recurso\index{recurso} de manera que se pueda determinar cuándo las tareas\index{tarea} pueden ser factiblemente\index{factible} realizadas. Cuando se especifican los recursos, se define efectivamente el alcance del problema de programación\index{programación!problema general}. Además, se describe cada tarea en términos informativos tales como su necesidad de recurso, su duración, el tiempo\index{tiempo} más pronto en el que puede comenzar, y el tiempo en el que debe llegar a su compleción. En general, la duración de la tarea es incierta, pero se puede suprimir la incertidumbre –si así se desea– cuando se formula el problema. También se debe describir cualquier restricción procedimental\index{restricción!procedimental} –restricciones de precedencia– que exista entre las tareas. La información acerca de los recursos y las tareas define un problema de programación. Sin embargo, encontrar una solución es frecuentemente una tarea compleja, y los planteamientos formales\index{formulación!planteamiento formal} para la solución del problema son beneficiosos \citetext{p.~2}. En la figura \ref{fig:programacion} se muestran las nociones expuestas anteriormente.

\begin{sidewaysfigure}
\includegraphics[width=\textheight]{scheduling.pdf}
\caption[La programación y sus elementos]{La programación y sus elementos}
\label{fig:programacion}
\end{sidewaysfigure}

\subsection{Programa, secuencia, horario}
\label{programa_secuencia_horario}

En ocasiones los términos programa\index{programa} (\textit{schedule}), secuencia\index{secuencia} (\textit{sequence}) y horario\index{horario} (\textit{timetable}) son utilizados a la ligera como si fueran sinónimos. Aquí se presentan algunas distinciones ajustándose a las prácticas aceptadas y procurando mantener tanta coherencia como sea posible.

Un \textbf{horario}\index{horario} muestra cuándo deben ocurrir eventos\index{evento} particulares. No necesariamente implica una asignación\index{asignación} de recursos\index{recursos}. Por ende, un horario publicado de trenes o autobuses muestra cuándo deben ocurrir las salidas para una o más rutas distintas, sin embargo, no nos dice cuáles vehículos o conductores han de ser asignados a trayectos en específico.
%
La asignación de vehículos y conductores es parte del proceso\index{programación!proceso} de programación. Aunque la calendarización\index{calendarización} (\textit{timetabling}) –la acción de producir horarios– es estrictamente el diseño del patrón\index{programación!patrón} de trayectos, este patrón puede ser concebido como parte de un proceso que toma en consideración si es probable que un programa\index{programa} eficiente pueda ser ajustado al patrón de trayectos resultante \cite[p.~48]{wren95scheduling-timetabling}.

En el ámbito ferroviario, el término calendarización\index{calendarización} es utilizado con frecuencia para referirse a la construcción de una ruta –con tiempos– para un tren a través de un sistema. Siendo así que el «Escocés Volador» –mundialmente famoso tren exprés de pasajeros que recorre desde 1862 el trayecto Londres-Edinburgo– solía partir de Edinburgo (estación \textit{Waverly}) a las 10:00; el trabajo de calendarización era el proceso de la búsqueda de tiempos y rutas a través del sistema de trenes que no conflictuaran con otro tráfico –haciendo revisiones en el resto del tráfico de ser necesario– hasta que llegaba a Londres (estación \textit{Kings Cross}) a las 18:30 (en 1922) o 18:05 (1948) 
\citep[p.~48, 49]{wren95scheduling-timetabling}.

Un horario\index{horario!educacional} educacional también muestra cuándo deben ocurrir eventos en particular. En ciertas circunstancias puede no haber actividad de programación\index{programación} necesaria para producir tal horario\index{horario}. En una escuela donde un único maestro es el responsable por todas las actividades\index{actividad} de una clase\index{clase} en particular, y donde dichas actividades\index{actividad} ocurren en un mismo lugar, un horario\index{horario} no es más que una declaración respecto a los tiempos en que deberán ocurrir actividades específicas –como en el caso del «Escocés Volador»–.
%
En contraste, un horario de exámenes para una universidad normalmente incluirá la asignación de aulas conociendo el tamaño de los grupos y de las instalaciones especiales requeridas. Habrá sido conformado sujeto a restricciones duras\index{restricción!dura} y suaves\index{restricción!suave}, como la cantidad de exámenes que puede presentar un estudiante en periodos consecutivos. Un horario de cursos para una universidad también tiene que tomar en cuenta la disponibilidad de los conferenciantes individualmente.
%
Es por ello que las actividades de calendarización de cursos\index{calendarización!de cursos} y calendarización de exámenes\index{calendarización!de exámenes} en universidades\index{horario!en universidades} pueden ser consideradas actividades\index{actividad} de programación\index{programación} \citep[p.~49]{wren95scheduling-timetabling}. 

Una \textbf{secuencia}\index{secuenciación!secuencia} es simplemente un orden en que las actividades\index{actividad} son llevadas a cabo. Por ejemplo, el orden en el que los trabajos son procesados a través de las máquinas en una fábrica, si los trabajos pasan a través de cada máquina en el mismo orden, es una secuencia. La secuenciación\index{secuenciación} puede tomar en cuenta costos relacionados a un trabajo específico siendo seguido por otro, como el costo de conversión de máquina. El problema de la secuenciación\index{secuenciación} de trabajos en estas circunstancias es conocido como un problema \textit{flow-shop}\index{secuenciación!flow-shop} \citep[p.~49]{wren95scheduling-timetabling}. 

Un \textbf{programa}\index{programa} normalmente incluirá toda la información espacial y temporal necesaria para que un proceso\index{proceso} llegue a término. Esto comprenderá los tiempos de inicio de las actividades\index{actividad} pertinentes, aserciones respecto a dónde serán asignados\index{asignación} cuáles recursos\index{recurso}, así como los planes de trabajo individuales para el personal o las máquinas.
%
Por consiguiente, la programación\index{programación} es el proceso\index{programación!proceso} de la elaboración del programa\index{programa}, incluyendo la asignación\index{asignación} de recursos\index{recurso} \citep[p.~49]{wren95scheduling-timetabling}.
%
En la figura \ref{fig:programa_secuencia_horario} se ilustran los conceptos anteriores.

\begin{sidewaysfigure}
\includegraphics[width=\textwidth]{media/programa_secuencia_horario.pdf}
\caption[Programa, secuencia, horario]{Programa, secuencia, horario}
\label{fig:programa_secuencia_horario}
\end{sidewaysfigure}

\subsection{El proceso de programación} % (fold)
\label{proceso_programacion}

De acuerdo a \citet{wren95scheduling-timetabling}, \textbf{el objetivo de la programación} es solucionar problemas prácticos relacionados a la asignación, sujeta a restricciones, de recursos a objetos siendo colocados en el espacio-tiempo, haciendo uso o desarrollando herramientas apropiadas. Los problemas con frecuencia buscarán la satisfacción de ciertos objetivos \citetext{p.~47}.

\citet{wren95scheduling-timetabling} prosigue mencionando que la programación\index{programación} puede ser vista como el acomodo de recursos dentro de un \textbf{patrón\index{programación!patrón} en el tiempo o espacio} de manera tal que algunos objetivos\index{objetivo} sean alcanzados –o se acerquen a ello– y que restricciones\index{restricción} existentes en la manera en que los recursos pueden ser acomodados sean satisfechas –o casi satisfechas–.
%
Los \textbf{recursos} pueden ser personas, vehículos, clases, exámenes, máquinas, trabajos en una fábrica, es decir, cualquier cosa que sea del interés del dueño del problema.
%
Con frecuencia la conformación de los recursos puede ser vista como parte del proceso de programación\index{programación!proceso}. Por ejemplo, las herramientras de trabajo en una fábrica pueden ser acomodadas por turnos de personal, los cuales deben ser agrupados en listas, esta formación de turnos puede ser vista como un proceso específico de programación dentro de un proceso más extenso \citetext{p.~48}.

El \textbf{patrón de programación}\index{programación!patrón} puede ser un orden de eventos, una estructura de rutas, una matriz de asignaciones, entre otros. El \textbf{patrón general de programación} puede tener que ser elaborado como parte del proceso de programación, o puede ser una plantilla\index{programación!plantilla} pre-existente característica del problema\index{programación!problema general} en cuestión \citep[p.~48]{wren95scheduling-timetabling}.

Las \textbf{restricciones}\index{restricción} definen conexiones físicas o permisibles entre los recursos\index{recurso}, y entre estos y el patrón\index{programación!patrón} de programación. Ellas gobiernan la manera en la cual los recursos pueden acomodarse juntos o dentro del patrón. Las restricciones pueden ser vistas como reglas que obstaculizan el logro de los objetivos\index{objetivo}. No obstante, también pueden ser vistas como parte de la especificación del problema\index{programación!problema general} siendo posible utilizarlas para guiar a la herramienta\index{programación!herramienta} de búsqueda de soluciones a una respuesta.
%
En la figura \ref{fig:scheduling_process} se presentan los conceptos ya descritos.
%
Algunas restricciones existen únicamente desde el punto de vista del dueño del problema y pueden formar parte del proceso\index{programación!proceso} de solución, con el propósito de mostrar hasta qué grado una solución podría ser mejorada si una restricción o restricciones fueran relajadas; de manera que el dueño pueda decidir si la restricción es realmente necesaria o si vale la pena hacer el esfuerzo de eliminarla de la definición del problema \citep[p.~48]{wren95scheduling-timetabling}.

\begin{figure}[hbtp]
\centering
\includegraphics[width=\textwidth]{media/scheduling_process.pdf}
\caption[El proceso de programación]{El proceso de programación}
\label{fig:scheduling_process}
\end{figure}

\subsection{Definiciones}
\label{Definiciones}

Para \citet[p.~5]{TKindt2002} los problemas de programación se encuentran en todo tipo de sistemas puesto que es necesaria para la organización y/o distribución del trabajo entre múltiples entidades. En cada libro pertinente de la literatura se presenta una definición así como sus componentes principales. Una de éstas es la enunciada por \citet{carlier1988problemes}: 
\begin{quotation}
La programación es predecir el procesamiento de un trabajo al asignar recursos a tareas y fijar sus tiempos de inicio\ldots Los diferentes componentes de un problema de programación son las tareas, sus restricciones potenciales, los recursos y la función objetivo\ldots Las tareas deben ser programadas para optimar un objetivo específico\ldots Por supuesto, frecuentemente será más realista en la práctica considerar múltiples criterios (como está citado en \citealp[p.~6]{TKindt2002}) 
\end{quotation}

Otra definición es la hecha por \citet[p.~1]{Pinedo1995}: «La programación es un proceso de toma de decisión\ldots  Se encarga de la asignación de recursos a tareas durante periodos y cuya meta es la optimación de uno o más objetivos.»

Algunos autores consideran a la programación\index{programación} (\textit{scheduling}) y calendarización\index{calendarización} (\textit{timetabling}) como actividades distintas, en este trabajo se utilizará el término programación\index{programación} como un término genérico y para cubrir tipos específicos de problemas, y se considerará a la calendarización\index{programación!calendarización} (\textit{timetabling}), secuenciación\index{programación!secuenciación} (\textit{sequencing}) y establecimiento de listas\index{programación!listas} (\textit{rostering}) como casos especiales de la actividad genérica de programación\index{programación} \citep[p.~47]{wren95scheduling-timetabling}.
%
En la sub-sección \ref{proceso_programacion} se definió el objetivo de la programación como:

\begin{quotation}
  solucionar problemas prácticos relacionados a la asignación, sujeta a restricciones, de recursos a objetos siendo colocados en el espacio-tiempo, haciendo uso o desarrollando herramientas apropiadas. Los problemas con frecuencia buscarán la satisfacción de ciertos objetivos.
\end{quotation}

Para \citet{wren95scheduling-timetabling}, las actividades de calendarización\index{programación!calendarización}, establecimiento de listas\index{programación!listas} y secuenciación\index{programación!secuenciación} todas se apegan a la definición anterior.
%
Sin embargo, se hará uso de las siguientes definiciones más restrictivas para este trabajo.

\begin{quotation}
La \textbf{programación} es la asignación, sujeta a restricciones, de recursos a objetos siendo colocados en el espacio-tiempo, de manera tal que se minimice el costo total de algún conjunto de los recursos usados. Ejemplos comunes son la programación de transporte o el diseño de rutas para vehículos de entrega que buscan minimizar el número de vehículos o conductores y dentro de ese mínimo de recursos, minimizar el costo total; y la programación \textit{job-shop} que puede buscar minimizar el número de periodo de tiempos usados, o algún recurso físico.

La \textbf{calendarización} es la asignación, sujeta a restricciones, de recursos dados a objetos siendo colocados en el espacio-tiempo, de manera tal que se satisfaga tanto como sea posible un conjunto de objetivos deseados. De ejemplo están la calendarización de cursos y exámenes y algunas formas de asignación de personal, como la ocupación de puestos en casetas de cobro sujetas a un número limitado de personal.

La \textbf{secuenciación} es la construcción, sujeta a restricciones, de un orden en el que determinadas actividades deben ser llevadas a cabo u objetos que deben ser colocados en alguna representación de una solución. Como ejemplos están la programación \textit{flow-shop} y el problema del agente viajero (\textit{travelling salesman problem; TSP}).

El \textbf{establecimiento de listas} es la colocación, sujeta a restricciones, de recursos en espacios dentro de un patrón. Se puede buscar alcanzar algún objetivo o simplemente lograr una asignación factible. Frecuentemente los recursos rotarán a través de una lista. \citetext{p.~53}
\end{quotation}

\begin{figure}[hbtp]
\includegraphics[width=\textwidth]{media/definiciones.pdf}
\caption[Definiciones]{La definición de programación, calendarización, secuenciación y establecimiento de listas}
\label{fig:definitions}
\end{figure}

Algunos problemas pueden encajar en más de una de las deficiones anteriores, y los términos tienen a ser utilizados de manera holgada en el área de trabajo y en la comunidad de investigación del área. En la figura \ref{fig:definitions} se puede ver una representación de lo expuesto con anterioridad.
%
En algunas definiciones se ha referido a la satisfacción o a la minimización. Debe ser resaltado que muchos de los problemas que se tratan en el área no tienen un objetivo bien definido. En ocasiones se puede justificar el uso de métodos de mejora o no-óptimos en parte porque los distintos dueños del problema tienen distintas perspectivas del objetivo, aunque en realidad tales métodos son frecuentemente utilizados simplemente porque no hay un método óptimo –o exacto– que sea viable en la práctica \citep[p.~53,~54]{wren95scheduling-timetabling}

\citet[p.~3]{Baker2009} recuerdan que muchos de los primeros desarrollos en el campo de la programación fueron motivados por problemas encontrados en la industria de la producción. Por lo tanto, es natural encontrar en la literatura el uso de vocabulario de producción cuando se describen problemas de programación. Aún cuando hoy día la aplicación de la programación es de considerable importancia en múltiples áreas no relacionadas con la producción, la terminología sigue siendo frecuentemente utilizada. Es por eso que a los recursos usualmente se les llama \textbf{máquinas} (\textit{machines}) y a las tareas se les llaman \textbf{trabajos} (\textit{jobs}). En ocasiones, los trabajos pueden consistir de varias tareas elementales llamadas \textbf{operaciones} (\textit{operations}). El ambiente del problema de programación es llamado el \textbf{taller de trabajo} (\textit{job-shop}), o simplemente, el \textbf{taller} (\textit{shop}). Por ejemplo, un problema de programación que trate con el procesamiento de pólizas de seguros en aseguradoras puede ser descrito de manera genérica como un «taller» de seguros que se encarga del procesamiento de «trabajos» de polizas por «máquinas» aseguradoras.

\section{Historia}
\label{historia_programacion}

El concepto de programación no es nuevo; las pirámides tienen más de 3,000 años, Sun Tzu escribió acerca de programación y estrategia desde una perspectiva militar hace 2,500 años, vías ferroviarias han sido construidas por alrededor de 200 años, entre otros muchos ejemplos. Ninguna de estas actividades pudo haber sido lograda sin alguna forma de programación –como lo es el entendimiento de conceptos como actividad y secuenciación–. Sin embargo, mientras que los administradores, sacerdotes y líderes militares en control de las organizaciones responsables por el logro de estas actividades debieron tener una apreciación por la programación –o al menos aquellos que tuvieron éxito– existe poca evidencia de procesos formales hasta la aparición del siglo XX \citep[p.~2]{Weaver2006}.

\begin{figure}[hbtp]
\centering
\includegraphics[width=.8\textwidth]{media/PriestleyChart.png}
\caption[Gr\'afica de Biograf\'ia]{Gr\'afica de Biograf\'ia abarcando los primeros 650 años antes de la era común. De \textit{A description of a chart of biography}, por J. \citeauthor{priestley1764description}, \citeyear{priestley1764description}. Derechos de autor expirados, obra del dominio público.}
\label{fig:chart_biography}
\end{figure}

De acuerdo a \citet{Weaver2006}, las herramientas de control de programación modernas pueden trazar sus orígenes hasta 1765. El creador de la «gráfica de barra» (\textit{bar chart}) parece ser Joseph Priestley (Inglaterra, 1733-1804); su «Gráfica de Biografía» (\textit{Chart of Biography}) mostraba unos 2,000 lapsos de vida de personajes notables en una gráfica con escala de tiempo, véase la figura \ref{fig:chart_biography}. Las ideas de Priestley fueron retomadas por William Playfair (1759-1823) en su «Atlas Comercial y Político» (\textit{Commercial and Political Atlas}) de 1786. A Playfair se le atribuye el desarrollo de un vasto rango de gráficas incluyendo la línea, la barra (histograma), y las gráficas circulares (gráficas de pastel), un ejemplo puede ser visto en la figura \ref{fig:playfair_timeseries} \citetext{p.~2,~3}.

\begin{sidewaysfigure}
\includegraphics[width=\textwidth]{media/Playfair_TimeSeries.png}
\caption[Gráfica del Atlas de W. Playfair]{Una de las gráficas elaboradas por Playfair. De \textit{The Commercial and Political Atlas}, por W. \citeauthor{playfair1786commercial}, \citeyear{playfair1786commercial}. Derechos de autor expirados, obra del dominio público.}
\label{fig:playfair_timeseries}
\end{sidewaysfigure}

\citet{Weaver2006} recuenta que siguiendo los pasos de Playfair, Karol Adamiecki –un polaco economista, ingeniero e investigador de la administración– desarrolló el harmonograma (\textit{Harmonogram}) en 1896. Este gráfico dispone de una escala de tiempo en el eje  vertical (en el lado izquierdo) y enumera las actividades en la parte superior. La hora de inicio y la duración de las actividades se muestra por una «barra deslizante» (\textit{sliding tab}), muy similar a la «barra» en una gráfica de barra. Lo relevante del harmonigrafo (\textit{Harmonygraph}) es que también tabula para cada actividad sus predecesores y sucesores haciéndolo un predecesor destacado de los sistemas \textit{CPM} y \textit{PERT} desarrollados unos 60 años después \citetext{p.~3}.

Para 1912, la gráfica de barras moderna parece estar totalmente desarrollada y es utilizada al menos en Alemania. Estas ideas fueron entonces divulgadas en EEUU por el consultor de administración estadounidense Henry L. Gantt, quien publicó «Trabajo, Sueldos y Utilidades» (\textit{Work, Wages, and Profits}) en 1916 en donde expresamente habla de la programación, especialmente en el ambiente de los talleres de trabajo. En su forma más pura, la gráfica de barras correlaciona actividades y tiempos en una presentación gráfica permitiendo la determinación de la temporización del trabajo pero no de sus interdependencias. Como se muestra en la figura \ref{fig:grafica_gantt}, la secuenciación es inferida en lugar de ser mostrada y en sus elaboraciones hechas a mano, las primeras gráficas eran una representación estática del programa \citep[p.~3]{Weaver2006}.

\begin{sidewaysfigure}
\includegraphics[width=\textwidth]{media/gantt-graphic.pdf}
\caption[Gráfica de Gantt]{Gráfica de Gantt. De \textit{Gantt charts: A centenary appreciation}, por J. M. \citeauthor{wilson2003gantt}, \citeyear{wilson2003gantt}, \textit{European Journal of Operational Research}, 149, p.~2. Derechos reservados [\citeyear{wilson2003gantt}] por \textit{European Journal of Operational Research}.}
\label{fig:grafica_gantt}
\end{sidewaysfigure}

La planeación de líneas de flujo (\textit{flowline planning}) fue desarrollada en la década de los treinta o aún antes y las gráficas de hitos (\textit{milestone chart}) también estuvieron en uso regular para la década de los cincuenta. Grandes contratos eran subdivididos en secciones con fechas límite de compleción del trabajo necesario para lograr cada hito (\textit{milestone}). Sin embargo, así como con las graficas de Gantt, todas las fechas y las relaciones mostradas en estas graficas estaban basadas en heurísticas o en experiencia. Era posible identificar retrasos pero cualquier valoración del impacto del mismo estaba basada en una interpretación personal de los datos y no de un análisis serio. Como consecuencia cuando el retraso de un programa se volvía aparente en grandes contratos, la tendencia era solucionar el problema inundándolo con mano de obra y «comprar tiempo» frecuentemente a un precio muy elevado.
%
Independiente del desarrollo de los procesos de control de programación basados en gráficas de barras y de hitos, la programación lineal había estado siendo investigada durante varios años. Esta rama de las matemáticas observaba las dinámicas de causa y efecto de acciones entre ellas mismas, en situaciones tales como el flujo de tráfico en una autopista. Uno los matemáticos involucrados en este trabajo fue James E. Kelley \citep[p.~4]{Weaver2006}.

\subsection{Método de la ruta crítica} % (fold)
\label{sub:Metodo_ruta_critica}

El origen del método de la ruta crítica (\textit{Critical Path Method; CPM}) data de mediados de 1956. La empresa Du Pont estaba en búsqueda de problemas que pudiera solucionar a través de su computadora «UNIVAC1» –una de las primeras computadoras instaladas en el ámbito comercial–. La administración de Du Pont acordó que el estudio de la planeación, estimación y programación sería un buen uso de la computadora. La encomienda de descubrir si una computadora podría ser programada para ayudar le fue otorgada a Morgan Walker. Muchos otros habían comenzado a estudiar el problema, incluso colegas de Du Pont pero ninguno había logrado un fin económicamente viable \citep[p.~4,~5]{Weaver2006}.

En el periodo desde fines de 1956 hasta abril de 1957, Walker con la asistencia de Kelly y otros había examinado un proyecto viable. El reto era solucionar el dilema del tiempo-costo. Podían demostrar que en lugar inundar un proyecto retrasado con mano de obra para recuperar tiempo perdido, enfocar el esfuerzo en las tareas «correctas» podía reducir el tiempo de compleción sin aumentar el costo de manera significante. El problema estriba en encontrar cuáles son las tareas «correctas» \citep[p.~5]{Weaver2006}.

El equipo de Du Pont era liderado por Morgan R. Walker, participantes clave provenientes del equipo Univac fueron James E. Kelley y John Mauchly. Kelley era el experto en matemáticas y cómputadoras nominado por Mauchly para solucionar el problema para Walker. La solución adoptada por Kelley estaba basada en la programación lineal y utilizaba la notación matemática de subíndices para describir la relación entre actividades. Esto limitaba la secuenciación y hacía posible que el cómputo fuera factible.
%
La solución creaba un par de retos significantes. Uno era la recopilación de los datos necesarios para cargar el modelo computacional. Los ingenieros no estaban acostumbrados a describir trabajo en términos de actividades (tareas) con requerimientos de recursos y distintos costos dependiendo de los recursos empleados para una duración «normal» y una duración «en crisis». La recopilación de los datos para el primer modelo \textit{CPM} le tomó a Walker más de tres meses. El otro problema era que la notación de subíndices carecía de sentido salvo para los matemáticos. El diagrama de «Actividad-en-Flecha» fue desarrollado para explicar las matemáticas a los administradores. A pesar de todos los problemas, el 24 de julio de 1957 el primer análisis del programa de \textit{George Fischer Works} había sido completado y el concepto comprobado. El programa incluía 61 actividades, 8 restricciones de tiempo y 16 restricciones ficticias. Una parte del programa puede ser visto en la figura \ref{fig:cpm_george_fischer_works} \citep[p.~5,~6]{Weaver2006}.

\begin{sidewaysfigure}
\includegraphics[width=\textwidth]{media/cpm_gfw.pdf}
\caption[Gráfica de CPM]{Una sección del programa \textit{CPM} de \textit{George Fischer Works}. De \textit{A Brief History of Scheduling}, por P. \citeauthor{Weaver2006}, \citeyear{Weaver2006}, p.~6. Derechos reservados [\citeyear{Weaver2006}] por \textit{Mosaic Proyect Services Pty Ltd}.}
\label{fig:cpm_george_fischer_works}
\end{sidewaysfigure}

El mayor reto luego se convirtió en reducir el número de cálculos y variables a un nivel que pudiera ser procesado en un tiempo razonable. El estimado del tiempo necesario para actualizar un programa de 150 a 300 flechas era de alrederdor de 350 horas de tiempo de computadora al mes. Algunos de los retos eran básicos: como tener acceso a la computadora adecuada; las cintas magnéticas con la información almacenada eran preparadas en las computadoras de Du Pont y después trasladadas atravesando EEUU para ser ejecutadas en máquinas capaces de analizar los datos. El desarrollo continuó todo 1958 y en marzo de 1959 Kelley y Walker de manera conjunta, presentaron \textit{CPM} al público en general en la Conferencia de Computadoras del Este Unido (\textit{Eastern Joint Computer Conference}) en un artículo llamado «Planificación y Programación de la Ruta Crítica» (\textit{Critical Path Planning and Scheduling}) \citep[p.~6]{Weaver2006}.

% subsection Método de la ruta crítica (end)

\subsection{Técnica de revisión y evaluación de programas} % (fold)
\label{sub:pert}

La Técnica de Revisión y Evaluación de Programas (\textit{Program Evaluation and Review Technique; PERT}) fue desarrollada por la Oficina de Proyectos Especiales de la Marina de los EEUU. Introdujo la incertidumbre a las duraciones del programa, pero la contribución más importante que hizo el equipo de \textit{PERT} a la programación fue la invención de la «ruta crítica» (\textit{critical path}). Kelly y Walker utilizaron el nombre «cadena principal» (\textit{main chain}) para la ruta más extensa a través del programa \citep[p.~7]{Weaver2006}.

A pesar de que \textit{PERT} y \textit{CPM} surgieron independientemente, son marcadamente similares, ambos usan la técnica de diagramas de flecha –con las flechas representando actividades– y son considerados como herramientas para la planeación y programación de grandes proyectos no-repetitivos. La diferencia fundamental es que el negocio de Du Pont era bien conocido –construcción y mantenimiento de plantas químicas– y las duraciones de las actividades podían ser estimadas con cierto grado de exactitud basándose en valores históricos conocidos y tasas de producción. Consecuentemente, \textit{CPM} se enfocó en la optimación de costos al hacer balance de recursos. El trabajo de la Marina fue meramente de investigación y desarrollo, contemplando el costo como un factor secundario; las duraciones solo podían estimarse y \textit{PERT} se enfocó en la determinación de la probabilidad de ocurrencia de un evento en una fecha futura. Sin embargo, su utilidad potencial tiene un alcance mucho más amplio. Ambos han ganado una rápida aceptación como útiles técnicas prácticas y han sido empleados exitosamente en diversas áreas, incluyendo investigación y desarrollo, construcción, manutención, mercadotecnia y producción. Para fines de la década de los sesenta tanto \textit{CPM} como \textit{PERT} se fusionaron en sistemas de administración basados en red \citep[p.~372,~8]{Baker2009,Weaver2006}.

% subsection Técnica de revisión y evaluación de programas (end)
\subsection{Desarrollo en otras partes del mundo} % (fold)
\label{sub:desarrollo_otras_partes_mundo}

El desarrollo de sistemas de programación no estuvo basado exclusivamente en EEUU. En Europa fueron desarrollados un número de sistemas aunque ninguno sobrevivió como herramienta preponderante. Para 1968 \textit{PERT} y \textit{CPM} habían emergido como las nomenclaturas estándar y los sistemas dominantes.

En el Reino Unido la compañía química ICI pudo haber desarrollado una herramienta tipo \textit{CPM} tan pronto como 1955 en sus instalaciones de Billingam. La programación del mantenimiento de la planta era realizado a través de la «duración de secuencia controlada» de ICI haciendo uso de datos de \textit{Work Study} para estimar las duraciones y una «red de secuenciación», desafortunadamente, poca información se ha encontrado respecto a este sistema. 
%
La Sección de Investigación de Operaciones (\textit{Operational Research Section; ORS}) del Consejo Central para la Generación de Electricidad (\textit{Central Electricity Generating Board; CEGB}) en los años 1957 y 1958 estuvieron involucrados en el desarrollo de su versión de \textit{CPM}. Al seguir desarrollando su método tipo \textit{CPM} y al aplicarlo al apagado y mantenimiento de la central eléctrica Keadby en Leicestershire en 1957, el \textit{CEGB} fue capaz de reducir el tiempo de apagado en un 42\% en comparación al promedio de años anteriores, y en 1960 alcanzó a mejorar la reducción en otro 32\%. Desafortunadamente estos sucesos no fueron ampliamente publicitados y cayeron en el olvido. Es posible que una parte significativa del trabajo de \textit{ORS-CEGB} haya sido integrado –o cuando menos influenciado– en los antepasados de la compañia ICL en el desarrollo de lo que se convirtió su software de programación para \textit{mainframe} «ICL PERT», así como sus sucesores para sistemas \textit{PC} como Micro Planner y PlanTrac \citep[p.~8]{Weaver2006}.

La URSS (Rusia) desarrolló su propio sistema tipo \textit{PERT} llamado \textit{Setevoe planirovanie i upravlenie}. Si bien no tuvo un impacto fuera de la URSS, los programadores rusos han desarrollado otras herramientas interesantes, una de las más recientes es el Proyecto ARAÑA (\textit{Project SPIDER}) –véase figura \ref{fig:screenshot_project_spider}– que enlaza dinámicamente tiempo, recursos y costo –el objetivo original del trabajo de Kelley y Walker– dentro de un perfil de riesgo controlado \citep[p.~8]{Weaver2006}.

\begin{sidewaysfigure}
\includegraphics[width=\textwidth]{media/spider_project_gray.pdf}
\caption[Interfaz del Proyecto ARAÑA]{Una captura de pantalla de la herramienta rusa de programación «Proyecto ARAÑA». De \textit{Spider Project Professional}, por P. \citeauthor{cotterell14spider-project}, \citeyear{cotterell14spider-project}, p.~2. Derechos reservados [\citeyear{cotterell14spider-project}] por \textit{Spider Project}.}
\label{fig:screenshot_project_spider}
\end{sidewaysfigure}

El método Metra Potencial (\textit{Metra Potential Method; MPM}) desarrollado en 1958 por el Sr. B. Roy con la consultoría METRA en Francia, pudo haber sido influenciado por avances en los EEUU pero parece haber sido inventado de manera independiente del trabajo del Dr. John Fondahl en el sistema de precedencias. \textit{MPM} empleaba un sistema gráfico de «nudos» –puntos y círculos– unidos por «tiras». Las «tiras» –líneas entre los nudos– podían o no tener una dirección de flujo pero sí especificaban el periodo de tiempo que una actividad estaba indicada a demorarse después del inicio de la actividad predecesora. La herramienta alemana «ACOS Plus 1» utiliza \textit{MPM} como su filosofía de programación aunque desde una perspectiva de usuario, \textit{ACOS} es similar a la mayoría de las herramientas de programación basadas en precedencia. Sin embargo, ACOS ofrece un número adicional de tipos de enlaces. \textit{MPM} fue probablemente el primer sistema en utilizar «demoras» en sus algoritmos de programación \citep[p.~8,~9]{Weaver2006}.

% subsection Desarrollo en otras partes del mundo (end)

\subsection{El método de diagramación de precedencias} % (fold)
\label{sub:metodo_programacion_precedencia}

En 1961 el Dr. John Fondahl publicó un reporte titulado «Un enfoque no-computarizado hacia métodos de ruta crítica para la industria de la construcción» (\textit{A Non-computer Approach to Critical Path Methods for the Construction Industry}). Este documento describió al sistema de programación \textit{PDM} (\textit{Precedence Diagramming Method}) y fue presentado como un proceso manual efectivo para evitar el uso del oneroso sistema basado en ordenadores \textit{CPM}.
%
El planteamiento desarrollado por el Dr. Fondahl hacia uso de un diagrama elaborado a partir de «círculos y línea conectoras» (\textit{circle and connecting lines}) derivado de los diagramas de flujo de procesos o gráficas de flujo –tanto \textit{CPM} como \textit{PERT} utilizaban la notación de Actividad-en-Flecha–. Algunos de los enfoques clave del planteamiento fueron:

\begin{itemize}
\item El impacto del intercambio tiempo/costo –el mismo problema que Kelley y Walker estaban trabajando–.
\item Responder a la pregunta «¿Puede el personal interno de los contratistas trabajar con \textit{CPM} sin tener acceso a ordenadores?»
\item La simplicidad percibida al hacer uso de gráficas de flujo.
\end{itemize}

A pesar del énfasis en la investigación del Dr. Fondahl en la no utilización de ordenadores, sus colegas en la firma Texana H.B. Zachry Co. de San Antonio comenzaron a trabajar en 1962 en la implementación del sistema como una herramienta de computación para los ordenadores centrales (\textit{Mainframes}) de IBM y al menos uno de los estudiantes del Dr. Fondahl, Dick Bryan (Stanford 1955) trabajó para Zachry, convirtiéndose en vice-presidente más tarde \citep[p.~9]{Weaver2006}.

El trabajo en Stanford continuó independientemente del proyecto de Zachry e incluyó el desarrollo de un proceso de actualización manual. Este reporte –Reporte Técnico No. 47– fue publicado en 1964 y causó una re-evaluación del nombre dado a este método. Los nombres en uso durante ese periodo para el método incluían «círculo-y-línea-conectora» (\textit{circle-and-connecting-line}), «operación y línea de interrelación» (\textit{operation and interrelation line}) y «Actividad-en-Nodo» (\textit{Activity-on-Node}) propuesto por Moder y Phillips en la primera edición de su libro «Administración de Proyectos con \textit{CPM} y \textit{PERT}» (\textit{Project Management with CPM and PERT}) publicado en 1964. Sin embargo, a comienzos de 1964 IBM anunció el lanzamiento de su «Sistema de Control de Proyectos» (\textit{Project Control System; PCS}) para la computadora 1440. \textit{PCS} utilizó el nombre «diagramación de precedencias» (\textit{precedence diagramming}) y el equipo de Stanford decidió adoptar el mismo nombre pues dado el uso de IBM, éste probablemente prevalecería \citep[p.~9]{Weaver2006}.

La transición del trabajo del Dr. Fondahl a un sistema basado en computadora parece haber sido diseñado por la compañía Texana de construcción Zachry. En 1958 el Sr. Zachry se hizo de un nuevo libro, «Investigación de Operaciones» (\textit{Operations Research}), y se lo dio a W.D. Tiner, Jr. –el Director de investigación en la firma– solicitándole su estudio y aplicación de sus métodos dentro de la compañía. Después de un estudio minucioso de los métodos y costos potenciales para el equipo de computación necesario, Tiner le comentó a Zachry que la compañía no podía solventar tal cantidad de dinero en los equipos. La respuesta de Zachry fue: «Doug, estás equivocado, no podemos no invertir en esos equipos».
%
La compañía Zachry comenzó a experimentar con el método de la ruta crítica (\textit{CPM}) en la programación de proyectos de construcción en 1959. Algunos de los primeros proyectos en beneficiarse de esta iniciativa incluyeron la construcción de una base de misiles Atlas en Abilene, Texas en 1960 haciendo uso de tiempo rentado en una IBM 650 y la construcción de una nueva instalación para Nike Zeus en la isla Kwajalein (en las Islas de Marshall) en 1961 haciendo uso de una computadora IBM 1620 instalada en las oficinas de Zachry \citep[p.~9,~10]{Weaver2006}.

% subsection El Método de Diagramación de Precedencias (end)

\subsection{La programación y la computadora} % (fold)
\label{sub:programacion_computadora}

La evolución de la programación siguió de cerca el desarrollo de las computadoras. Los primeros sistemas eran computadoras centrales gigantescas, típicamente le tomaba a un nuevo programador muchos meses aprender a utilizarlas. Estos sistemas migraron a las mini-computadoras de la década de los setenta y ochenta pero continuaron siendo onerosos, fomentando así el uso generalizado de técnicas manuales de programación, solo las organizaciones más grandes –o más sofisticadas– pudieron sufragar una oficina central de programación y los sistemas de cómputo necesarios. 
%
El advenimiento de la micro-computadora –entiéndase la \textit{PC} o computadora personal– cambió la programación para siempre. La evolución de la programación basada en tecnología \textit{PC} cambió los controles del proyecto, de un ambiente en donde un equipo especializado de programadores operaba sistemas costosos asegurándose que la programación fuera correcta –y que la organización tuviera el control de los datos– a una situación en donde cualquiera podía aprender a manejar un paquete de software de programación; los programas se convirtieron en «islas de información» dispersas en los escritorios de los empleados y la calidad de la programación en general se desplomó \citep[p.~2]{Weaver2006}.

En la actualidad, hay tendencias de un regreso a los sistemas empresariales soportados por paquetes Ofimáticos de Administración de Proyectos (\textit{Project Management Office; PMO}) que remedian el equilibrio y ofrecen lo mejor de los dos mundos. Desde un punto de vista tecnológico, la información es gestionada de manera central, pero está disponible fácilmente para todos en cualquier \textit{PC} a través de una interfaz de red. Desde el punto de vista de habilidades, los \textit{PMO} están teniendo un impacto en el desarrollo de las carreras de los programadores y apoyando en la implementación de estándares de programación dentro de las organizaciones \citep[p.~2]{Weaver2006}.

Antes de la década de los ochenta la programación era considerado un asunto muy serio; hacía uso de recursos costosos, requería de significante entrenamiento y habilidad, y estaba mayormente centralizada y visible. En donde se hacía uso de la programación manual, los ahorros en costos de operación eran contrarrestados por el tedio de las extensas computaciones manuales; no era redituable cometer equivocaciones, por ende los programadores eran profesionales entrenados.
%
La llegada de herramientas de programación «fáciles de utilizar» con una interfaz gráfica cambió radicalmente a la industria. La programación migró al escritorio y surgió el mito de que «cualquiera» podía crear un programa –considerando que supiera encender una \textit{PC}–. Mucha gente aprendió «programación» al usar herramientas como \textit{Microsoft Project}. No había entrenamiento o supervisión y como consecuencia, el programa promedio estaba inundado de «arreglos» permitidos o incluso fomentados por la herramienta. La tendencia ha sido hacia un enfoque en los procesos computacionales y la obtención de un programa que se «vea bien» en lugar de el análisis de un proyecto para determinar la duración apropiada basada en las disponibilidades de los recursos apropiados y en el diseño de un programa como una herramienta efectiva para la administración en el contexto de cada proyecto en específico \citep[p.~12,~13]{Weaver2006}.

\chapter{Teoría de la programación}
\label{teoria_programacion}

Según \citet[p.~1]{TKindt2002}, la teoría de la programación aparece a mediados de la década de los cincuenta. Desde entonces los problemas planteados se han aproximado cada vez más a aplicaciones industriales incrementando por tanto su complejidad. La disposición de los talleres tomados en consideración se asemejan cada vez más y más a lo encontrado en la práctica; al mismo tiempo las restricciones impuestas son cada vez más concretas.  Paradójicamente, la literatura muestra que en la mayoría de los problemas planteados, los programas son evaluados por un \textbf{único} criterio.

Durante las diferentes etapas de planificación distintos criterios pueden ser considerados. A un nivel estratégico, una \textbf{planificación de largo alcance} puede contemplar varios años, los objetivos se preocupan con la minimización de costos relacionados a los planes de inversión para materiales, finanzas, o personal, relacionados a la elección de nuevas oportunidades de negocio, o al lanzamiento de campañas de publicidad. Para la planificación estratégica en una \textbf{fase de mediano plazo} con varios meses en mente, los objetivos se enfocan a la minimización de costos: costos de inventario, costos de transporte de insumos, costos de modificación en la capacidad de producción, costos de lanzamiento, costos de modificación de sistemas de producción entre otros. Durante una fase de planificación o una fase de \textbf{programación a corto plazo} –un periodo de tiempo de una semana– multiples objetivos requieren la atención del ejecutivo de producción: ante todo, debe considerar los retrasos para la satisfacción del cliente, acto seguido, debe minimizar el costo del trabajo en proceso de la producción, y finalmente debe minimizar los costos de producción relacionados al tiempo utilizado para la configuraciónd de la maquinaria o los tiempos muertos de las mismas. Es por ello, que un problema de programación puede contemplar multiples criterios de manera tal que permita ofrecer al dueño del problema soluciones más realistas\citep[p.~1]{TKindt2002}.

De acuerdo a \citet[p.~3,~4]{Baker2009}, la teoría de la programación se preocupa primordialmente con modelos matemáticos que se relacionan al proceso de programación. El desarrollo de modelos útiles, los cuales derivan en técnicas de solución y perspectivas prácticas, han sido la interfaz continua entre la teoría y la práctica. 
%
La perspectiva teorética es también en gran medida un acercamiento cuantitativo, uno que intenta capturar la estructura del problema en una forma matemática.
%
En particular, este enfoque cuantitativo comienza con la descripción de los recursos y tareas, y con la traducción de objetivos de planificación en una \textbf{función objetivo} explícita.

Idealmente, la función objetivo debe consistir de todos los costos que dependan de decisiones de programación. En la práctica, sin embargo, tales costos son frecuentemente difíciles de medir, o incluso de identificar en su totalidad. Los costos de operación mayores –y los más fácilmente identificables– son determinados por la \textbf{función de planificación}, mientras que los costos relacionados con la programación son difíciles de aislar y frecuentemente tienden a dar la impresión de ser costos fijos. Sin embargo, tres tipos de objetivos relativos a la toma de decisiones parecen ser prevalentes en la programación: plazo (\textit{turnaround}), puntualidad (\textit{timeliness}) y rendimiento (\textit{throughput}). El plazo cuantifica el tiempo requerido para completar una tarea. La puntualidad evalúa la conformidad de la compleción de una tarea particular sujeta a una fecha límite. El rendimiento mide la cantidad de trabajo completado durante un periodo fijo. Los primeros dos objetivos requieren más elaboración pues aun cuando se puede juzgar el plazo o la puntualidad de una tarea dada, los problemas de programación requieren una evaluación de desempeño para el conjunto total de tareas en un programa. El rendimiento, en contraste, ya es un indicador que aplica a todo el conjunto \citep[p.~4]{Baker2009}.

\section{Áreas de aplicación}
\label{areas_aplicacion}

Los problemas de programación se encuentran en todos los niveles y en todos los sectores de la actividad económica. Generalmente, se hace una distinción entre aquellos relacionados a la industria de la fabricación y aquellos relacionados a los sistemas de cómputo o administración de proyectos \citep[p.~6]{TKindt2002}.

\subsection{Problemas relacionados a la producción} % (fold)
\label{problemas_relacionados_produccion}

Los problemas de programación se encuentran en los sistemas de manufactura flexible (\textit{FMS; Flexible Manufacturing System}). Numerosas definiciones de un \textit{FMS} existen en la literatura. Para \citet{liu1996classification}, «un FMS comprende tres elementos principales: herramientas de maquinaria controladas por computadora; un sistema de transporte automatizado y un sistema de control por computadora» (como está citado en \citealp[p.~6]{TKindt2002})  Estos problemas son tratados en la literatura y seguido en una bien definida clase de aplicación. Además, este amplio problema abarca otros problemas relacionados con la \textbf{Programación de Celdas Robotizadas} y la \textbf{Programación de Vehículos Guiados Automatizados}.

Igualmente, la \textbf{electrodeposición} y los \textbf{talleres químicos} tienen sus propias peculiaridades en los problemas de programación. El último también es conocido como Problemas de Programación de Grúas. Estos talleres se caracterizan por la presencia de una o más grúas compartiendo el mismo espacio físico y donde deben transportar productos para tratamientos en tanques. Por lo general, el tiempo de submersión en un tanque está limitado por un mínimo y un máximo –el intervalo del tiempo de procesamiento–, el tiempo de transporte no es despreciable y las operaciones deben ser llevadas a cabo sin tiempos de espera. Estos problemas son muy comunes en la industra y los casos simples –mono-robot, tanques de una pasada, etc.– ya tienen planteadas buenas soluciones \citep[p.~6,~7]{TKindt2002}.

Los problemas de programación en las \textbf{líneas de producción automotrices}, también conocidos como «Problemas de Secuenciación Automotriz» (\textit{Car Sequencing Problems}), se encuentran en los talleres de ensamblado donde cierto equipamiento u opciones deben ser incorporados a distintos modelos de vehículo. Estos problemas tienen restricciones y peculiaridades particulares. Teniendo conocimiento de una secuencia de vehículos en curso de tratamiento, el problema es determinar el tipo adecuado de vehículo siguiente. Es necesario tomar en consideración el grupo de restricciones enlazadas principalmente a las opciones de emsamblado para estos vehículos y al limitado rango de movimiento de las herramientas dispuestas a lo largo de la línea de producción \citep[p.~7]{TKindt2002}.

\subsection{Otros problemas}
\label{otros_problemas}

\citet[p.~7]{TKindt2002} continua, afirmando que se encuentran problemas de programación en los \textbf{sistemas computacionales}. Estos problemas son estudiados de distintas maneras al discriminarlos por sistemas mono o multi procesador, con las restricciones de sincronización de operaciones y compartición de recursos. En estos problemas, ciertas operaciones son periódicas y otras no, algunas están sujetas a fechas de cierre, otras a fechas límite. El objetivo es encontrar una solución factible, es decir, una solución que satisfaga las restricciones. Estos problemas abundan en la literatura. De hecho, a pesar de las apariencias son bastante cercanos a los problemas encontrados en los sistemas de producción.

Los \textbf{problemas de programación de horarios escolares} conciernen a todas las instituciones educativas o universidades, dado que involucran la calendarización de cursos asegurando la disponibilidad de profesores, estudiantes y aulas. Estos problemas son ampliamente estudiados \citep[p.~7]{TKindt2002}.

Los \textbf{problemas de programación de proyectos} comprenden una vasta literatura. El interés general se concentra en la programación de operaciones que hacen uso de multiples recursos simultáneamente (dinero, personal, equipo, materiales, etc), estos recursos estando disponibles en cantidades conocidas. En palabras precisas son problemas de programación multi-recurso haciendo uso de recursos acumulativos no-renovables \citep[p.~7]{TKindt2002}.

\section{Tipología y notación de problemas}

En el tema de los problemas de programación se hace una distinción entre su tipología y su notación. Una tipología es una clasificación de los problemas de acuerdo a su naturaleza. En la programación usualmente está basada en el contexto de las máquinas y en las particularidades de los trabajos. Una notación nos permite referirnos rápidamente a un problema, siendo así que es posible construir una base de datos del conjunto de problemas vistos en la literatura \citep[p.~14]{TKindt2002}.

\subsection{Tipología de problemas}

Existen diferentes tipologías de problemas de programación en la literatura. En la figura \ref{fig:typology_maccarthy} se presenta una generalización del trabajo hecho por \citet{maccarthy1993addressing} (como está citado en \citealp[p.~14]{TKindt2002}). En los problemas de programación el objetivo es determinar una secuencia para cada máquina y un tiempo de inicio para cada operación. En problemas de programación y asignación con etapas se pueden definir, independientemente de cada operación, etapas de máquinas. Una máquina pertenece a una sola etapa. Entonces, se combina cada operación con una etapa, y una operación puede ser procesada por cualquier máquina de de su etapa. Por lo tanto, se incorpora un problema de asignación al problema inicial de programación. Ya no es suficiente determinar el tiempo de inicio para las operaciones, es necesario establecer la asignación de las operaciones en las máquinas. Lo mismo ocurre para los problemas generales de programación y asignación en donde un conjunto de máquinas es detallado para cada operación. Por supuesto, una máquina puede existir en más de un conjunto y una operación puede ser llevada a cabo por cualquier máquina perteneciente al mismo conjunto.

\begin{figure}[hbtp]
\centering
\includegraphics[width=.8\textwidth]{media/typology_maccarthy_spanish.pdf}
\caption[Tipología basada en el contexto de máquinas y operaciones]{Tipología generalizada de problemas de programación de acuerdo a las proposiciones de \citet{maccarthy1993addressing}. De \textit{Multicriteria Scheduling: Theory, Models and Algorithms}, por V. \citeauthor{TKindt2002}, \citeyear{TKindt2002}, p.~15. Derechos reservados [2006] por \textit{Springer-Verlag Berlin Heidelberg}.}
\label{fig:typology_maccarthy}
\end{figure}

La tipología anterior hace uso del ambiente de las máquinas y operaciones para distinguir los problemas. Existen otras tipologías, se pueden estudiar los problemas de acuerdo sus distintas características –véase la fig \ref{fig:typology_cubic}–:

\begin{enumerate}[1]
\item \textbf{determinístico vs. estocástico}. En la situación donde todas las características del problema son bien conocidos, se habla de un problema \textbf{determinístico}. Por otra parte, algunas características pueden consistir de variables aleatorias de ley de probabilidad conocida. En este caso se habla de un problema \textbf{estocástico}.
\item \textbf{unitario vs. repetitivo}. Si las operaciones aparentan ser cíclicas, se trata de un problema \textbf{repetitivo}. En cambio, si cada operación corresponde a un producto único se dice que el problema es \textbf{unitario}.
\item \textbf{estático vs. dinámico}. Si toda la información del problema es conocida al mismo tiempo es un problema \textbf{estático}. Para algunos problemas, un programa puede haber sido elaborado con cierta información y ser ejecutado mientras aparecen nuevas operaciones en el sistema. Entonces el programa anterior tiene que ser restablecido «al momento». Estos problemas se les conoce como \textbf{dinámicos}.
\end{enumerate}

\begin{figure}[hbtp]
\centering
\includegraphics[width=.8\textwidth]{media/typology_cubic.pdf}
\caption[Tipología basada en características]{Tipología de los problemas de programación de acuerdo a sus características. De \textit{Multicriteria Scheduling: Theory, Models and Algorithms}, por V. \citeauthor{TKindt2002}, \citeyear{TKindt2002}, p.~16. Derechos reservados [2006] por \textit{Springer-Verlag Berlin Heidelberg}.}
\label{fig:typology_cubic}
\end{figure}

Estas dos tipologías son complementarias pues es posible trabajar, como ejemplo, con un problema \textit{flow-shop} determinístico, sea unitario o estático. Como será evidente en la próxima sección, la notación tradicional de los problemas de programación es un reflejo de estas tipologías \citep[p.~16]{TKindt2002}.

\subsection{Notación}

dibidi daba
asdf
asdf

\section{Teoría de la complejidad computacional} % (fold)
\label{teoria_complejidad_computacional}

Una perspectiva útil en cuanto a la relación de los problemas de programación y sus técnicas de solución viene de los avances de una rama de la ciencia computacional conocida como \textbf{teoría de la complejidad computacional}. La noción de la complejidad se refiere al esfuerzo computacional requerido por un algoritmo de solución. El esfuerzo de computación es descrito con una notación de orden de magnitud.
%
Por ejemplo, se hace uso de un algoritmo en particular para resolver un problema de tamaño \textit{n}. (Técnicamente, \textit{n} denota la cantidad de información necesaria para especificar el problema.) El número de computaciones requeridas por el algoritmo típicamente está vinculado desde encima por una función de \textit{n}. Si la orden de magnitud de esta función es polinomial conforme \textit{n} se agranda, entonces se dice que el algoritmo es polinomial.
%
Por ejemplo, si la función tiene una orden de magnitud $\textit{n}^2$, denotada por $\BigO(\textit{n}^2)$ entonces el algoritmo es polinomial. Por otra parte, si la función es $\BigO(2^\textit{n})$, entonces el algoritmo es no-polinomial (en este caso sería exponencial). Siendo todo lo demás igual, son preferibles los algoritmos polinomiales puesto que conforme \textit{n} se agranda, estos son ultimadamente más rápidos.

\section{Síntesis de los problemas de programación}
\label{sintesis_problemas_programacion}

Los problemas encontrados en la programación son infinitamente variados y tienen potencialmente una aplicación en cualquier contexto económico imaginable como la informática, la construcción, la industria y la administración. A continuación se reseñan de manera general los problemas que conforman la programación.

\subsection{Problemas centrales de programación}
\label{problemas_centrales_programación}

\citet{gotha93les-problemes-dordonnancement} califica de «centrales» a los problemas de programación sin restricciones de recursos, en donde tales son suficientes sin importar el programa que resulte \citetext{p.~89}. 

En el problema central clásico de programación se busca la ordenación de tareas sujetas a restricciones de secuencia y de tiempo, dentro de un periodo mínimo \citep[p.~90]{gotha93les-problemes-dordonnancement}. 

El problema central de recursos consumibles consiste de tareas vinculadas por restricciones potenciales, las cuales deben ser ordenadas en un periodo mínimo; cada tarea consume en un principio una cantidad determinada de unidades de un recurso consumible. Al comienzo del programa, hay disponibles una cantidad conocida de tales recursos y se espera la disponibilidad de recursos adicionales para fechas futuras; este modelo representa, como ejemplo, el financiamiento de un logro \citep[p.~90,~91]{gotha93les-problemes-dordonnancement}.

El problema central cíclico consiste de un conjunto finito de tareas genéricas. Una tarea genérica produce una infinidad de instancias, todas de la misma duración. Un conjunto finito de restricciones de precedencia genéricas vincula las tareas genéricas; una de estas restricciones es especificada por una tripleta $(i, j, h)$ en donde $i$ y $j$ son dos tareas genéricas, y $h$ es un entero natural llamado «\textit{hauteur}». Esto significa que por cada entero $n$, la instancia $(j, h+n)$ no puede comenzar su ejecución sino después de que haya sido completada la instancia $(i,n)$ \citep[p.~92]{gotha93les-problemes-dordonnancement}.

\subsection{Problemas enfocados en un recurso único}
\label{problemas_enfocados_recurso_unico}

Los problemas pertinentes a esta sección tratan con un recurso único individual o con $m$ instancias idénticas. Estos problemas pueden parecer muy específicos, sin embargo su resolución es la base de otros problemas más generales, especialmente cuando parece que un recurso es dominante. 
%
El problema básico consiste en determinar para un recurso la secuencia óptima de $n$ tareas disponibles al instante del inicio. Los criterios de solución primordiales son la duración total y la suma de retardos. Si se conoce información de disponibilidad la minimización de la suma de retardos entonces es un problema difícil-NP. Respecto a la minimización de la duración total se procura la ordenación de un conjunto de tareas independientes en un recurso único para tal propósito; cada tarea está caracterizada por su tiempo de disponiblidad, su duración y su latencia \citep[p.~94-96]{gotha93les-problemes-dordonnancement}. 

En los problemas clásicos de $m$ recursos se asume que cada tarea requiere de un recurso y que se dispone del mismo en $m$ ejemplares idénticos. Generalmente la solución de estos problemas tiene como criterio la minimización de la duración total; los mismos son casi siempre NP-difíciles salvo en los casos particulares de periodos unitarios y dos recursos o de periodo unitario y un árbol de precedencia dando lugar a algoritmos de listas óptimas. En ciertos problemas de programación, una restricción de sucesión está asociada a una transferencia entre los recursos que llevan a cabo las dos tareas. En las aplicaciones computacionales un ejemplo sería la transferencia de datos entre las dos tareas. La duración de esta transferencia depende de las dos tareas pero también de la distancia entre los dos recursos. Estos problemas de programación distribuida, por supuesto son más difíciles que los problemas de programación convencionales de $m$ recursos puesto que los contienen como casos especiales \citep[p.~99]{gotha93les-problemes-dordonnancement}.

\subsection{Problemas enfocados en múltiples recursos}
\label{problemas_enfocados_multiples_recursos}

Los problemas de programación con restricciones de recursos renovables son comúnmente conocidos como problemas de talleres puesto que se les encuentra en la administración de la producción. Sin embargo, son problemas muy generales que aparecen en otros contextos, en especial en las ciencias computacionales \citep[p.~101]{gotha93les-problemes-dordonnancement}.

En los problemas de taller (\textit{job-shop}) una tarea es una operación, un recurso es una máquina y cada operación requiere para su realización una máquina. En el modelo básico del problema, el taller está constituido por $m$ máquinas y $n$ trabajos (\textit{jobs}) disponibles al inicio deben ser realizados, un trabajo $i$ está constituido por $n_i$ operaciones, la operación $j$ del trabajo $i$ tiene la notación $(i,j)$ en donde $(i,1)<(i,2)<\ldots<(i,n_i)$ si el trabajo $i$ tiene una serie. Una operación $(i,j)$ utiliza la máquina $m_{i,j}$ durante toda su duración $p_{i,j}$ y no puede ser interrumpida \citep[p.~102]{gotha93les-problemes-dordonnancement}.

Los problemas se pueden clasificar de acuerdo al orden de utilización de las máquinas para fabricar un producto –fabricación en serie–. Existen problemas en donde los talleres hacen uso de una ruta única donde todas las series son idénticas –\textit{flow-shop}–, talleres con múltiples rutas en donde cada producto o familia de productos contiene –\textit{job-shop}– o no contiene –\textit{open-shop}– una serie específica. Las fechas de inicio de las operaciones $(i,j)$ constituyen las incognitas del problema y su determinación definen la ordenación. Las restricciones son disyuntivas; la elección de una secuencia sobre una máquina genera los conflictos de uso para la misma \citep[p.~102]{gotha93les-problemes-dordonnancement}.

El modelo básico puede ser extendido de varias maneras como asumiendo la existencia de fechas límite expiradas, la posible interrupción de una operación –con o sin memoria del trabajo parcialmente realizado–, el tiempo de preparación, que la disponibilidad de máquinas varíe en el transcurso del programa, que la capacidad de los recursos sea fraccional o la utilización de múltiples recursos para una operación \citep[p.~102]{gotha93les-problemes-dordonnancement}.


\subsection{Problemas de ordenación cíclicos}
\label{problemas_ordenacion_ciclicos}

Este tipo de problemas tienen numerosas aplicaciones en el ámbito informático –computaciones cíclicas en arquitecturas paralelas– como en el dominio de la producción –\textit{job-shops} cíclicos– o de la planificación –asignación periódica de recursos–. La investigación de estos problemas ha sido realizada apegándose a sus respectivas aplicaciones y el desarrollo de heurísticas para la obtención rápida de una solución aproximada. Si bien hay mucho interés en el estudio teorético de los problemas subyacentes, la división de los investigadores por sus campos de aplicación ha imposibilitado su estudio \citep[p.~131]{gotha93les-problemes-dordonnancement}.

\chapter{Una visión general del problema}
\label{vision_general_problema}

\section{Introducción}
\label{introduccion_vision_general}

En las secciones \ref{calendarizacion_clases}, \ref{calendarizacion_cursos} y \ref{calendarizacion_examenes} se presentan de manera general las formulaciones formales de los problemas.
La sección \ref{problema_general_programacion_horarios} presenta el problema general de la programación de horarios\index{programación!problema general}. La sección \ref{clasificacion_problemas} presenta una clasificación\index{calendarización!clasificación} de los tipos de problemas encontrados en la programación de horarios educacionales. 
\section{El problema general de la programación de horarios}
\label{problema_general_programacion_horarios}

\index{horarios!programación!problema general}
\citet[p.~53]{wren95scheduling-timetabling} definió la programación de horarios como “la asignación, sujeta a restricciones\index{restricción}, de recursos\index{recurso} dados a objetos siendo acomodados en un espacio-tiempo, de tal manera que se satisfagan tanto como sea posible un conjunto de objetivos deseados.”

\iffalse
Timetabling is the allocation, subject to constraints, of given resources to objects being placed in space-time, in such a way as to satisfy as nearly as possible a set of desirable objectives. Examples are class and examination timetabling and some forms of personnel allocation, for example manning of toll booths subject to a given number of personnel.

“Timetabling is the allocation, subject to constraints, of given resources to objects being placed in space time, in such a way as to satisfy as nearly as possible a set of desirable objectives.”
\fi

\section{Calendarización educacional} % (fold)
\label{calendarizacion_educacional}


\section{Clasificación de los problemas en el ámbito educacional}
\label{clasificacion_problemas}

\index{clasificación}
El problema de la programación de horarios educacionales\index{horarios!educacionales} se clasifica en tres clases principalmente:
calendarización de clases\index{horarios!de clases} (\textit{school timetabling}),
calendarización de cursos\index{calendarización!de cursos} (\textit{course timetabling}) y
calendarización de exámenes\index{calendarización!de exámenes} (\textit{examination timetabling}) \citep[p.~88]{schaerf99a-survey-of-automated}.

Todos tienen en común las características básicas del problema general de programación de horarios\index{horarios!problema general} pero pueden presentar diferencias significativas entre ellos. Cada problema cuenta con su propias restricciones\index{restricción}, requerimientos\index{requerimiento} y reglas\index{regla}. Son agrupados por su ámbito de aplicación en horarios en escuelas\index{horarios!en escuelas} y horarios en universidades\index{horarios!en universidades} \citep[p.~10]{abdullah06heuristic-approaches}.

\begin{figure}[hbtp]
\centering
\includegraphics[width=\textwidth]{timetabling_classification.pdf}
\caption[Clasificación del problema]{Clasificación de los problemas en la elaboración de horarios educacionales}
\label{fig:timetabling_classification}
\end{figure}

\iffalse
Classification of Educational Timetabling Problems
Schaerf (1999a) classified educational timetabling into three main classes i.e. school timetabling, course timetabling and examination timetabling. They share the same basic characteristics of the general timetabling problem but can still have significant differences between them. Each one of them has its own constraints, requirements and rules. More details on educational timetabling can be found in Burke et al. (2004e). In this section, a classification of educational timetabling and its properties are discussed. We divided educational timetabling into two categories i.e. school timetabling and university timetabling (which consists of examination timetabling and course timetabling).
\fi

\subsection{Horarios en escuelas}

\index{horarios!en escuelas}

\subsubsection{Horarios de clases}

\index{horarios!de clases}
De acuerdo a \citet[p.~88]{schaerf99a-survey-of-automated} el problema de horarios de clases consiste en calendarizar en un periodo semanal todas las clases de una escuela, evitando que los profesores se encuentren con dos clases al mismo tiempo, y viceversa. \citet[p.~10,11]{abdullah06heuristic-approaches} elabora explicando que el problema consiste de un conjunto de profesores, clases, lecciones y periodos semanales. En donde tales periodos semanales son predefinidos.

El problema intenta asignar lecciones a periodos y, un profesor a una clase en particular en un momento dado mientras se satisface un conjunto de restricciones con el fin producir un horario factible. Algunos ejemplos de restricciones en este tipo de problemas son las capacidades de alojamiento, ubicaciones, cargas de trabajo de los profesores, tiempo de descanso entre lecciones.

\subsection{Horarios en universidades}

\index{horarios!en universidades}\index{calendarización!de cursos}\index{calendarización!de exámenes}
El problema de la planificación de horarios en universidades puede ser agrupado en dos categorías: (i) calendarización de cursos y (ii) calendarización exámenes.
El problema de la calendarización de cursos es el proceso de la asignación de periodos y aulas de manera tal que las reuniones entre conferenciantes y estudiantes pueda ocurrir.
El problema de la calendarización de exámenes se refiere a la asignación de periodos y aulas de manera tal que los estudiantes puedan presentar sus exámenes.
Ambos problemas son similares de manera superficial, pero existen diferencias importantes que los distinguen.
En la calendarización de exámenes, múltiples exámenes pueden ser presentados en una misma aula (ej. auditorio) al mismo tiempo.
Sin embargo, esto no es posible para la calendarización de cursos en donde únicamente un curso puede ser asignado a un aula \citep[p.~11]{abdullah06heuristic-approaches}.

\subsubsection{Calendarización de exámenes}

\index{calendarización!de exámenes}\index{calendarización!de cursos}
\citet[p.~4]{carter95recent-developments} definió el problema como la asignación de exámenes a un número limitado de periodos de manera tal que no existan conflictos o coincidencias. Los problemas de calendarización de cursos y exámenes son similares pero algunas diferencias relevantes según \citet[p.~159]{werra85an-introduction-to-timetabling} son:
\begin{enumerate}[a]
\item Existe generalmente un solo exámen por cada tema (mientras que hay varias exposiciones en un curso)
\item En la calendarización semanal de cursos, el objetivo principal es evitar conflictos (ej. la ocurrencia de que dos cursos elegidos por un mismo estudiante sean programados en el mismo periodo). Para los exámenes, generalmente se pide un máximo de un examen por día para cada estudiante o de ser posible, evitar la calendarización de exámenes en días consecutivos si el periodo de evaluación de exámenes lo permite.
\end{enumerate}
El problema de la calendarización de exámenes es muy común tanto en escuelas como en universidades. La asignación de los exámenes a los periodos está sujeta a un conjunto de limitaciones \citep[p.~12]{abdullah06heuristic-approaches}.

\subsubsection{Calendarización de cursos}

\index{calendarización!de cursos}
El problema de la calendarización de cursos surge cuando una universidad (o incluso una escuela) ofrece una colección de cursos (cada uno consistiendo de un número dado de conferencias) sin existir un currículo fijo y en donde cada estudiante puede elegir cierto número de cursos. El problema consiste en la asignación de cada lectura a algún periodo en la semana de manera tal que ningún estudiante requiera asistir a más de una conferencia a la vez \citep[p.~157]{werra85an-introduction-to-timetabling}.
\citet[p.~88]{schaerf99a-survey-of-automated} define el problema como la calendarización semanal de todas las lecciones de un conjunto de cursos universitarios, minimizando los empalmes de las lecciones de cursos teniendo estudiantes en común.

\section{Calendarización de clases}
\label{calendarizacion_clases}

\section{Calendarización de cursos}
\label{calendarizacion_cursos}

\section{Calendarización de exámenes}
\label{calendarizacion_examenes}


\chapter{El gestor escolar}

\section{Aplicaciones}

\subsection{Métricas de desempeño}
\subsection{Diagnóstico}
\subsection{Multidisciplinario}

\section{Factores de interés}

\subsection{Laborales}

\subsubsection{Regulatorios}


\subsubsection{Interinstitucional}

\subsection{Inversión}

\subsubsection{Downsizing}

\subsection{Económicos}

\subsubsection{Utilidades}

\subsubsection{Fiscales}

\subsubsection{Aprovechamiento de recursos}

\subsection{Sociales}

\subsubsection{Involucramiento de paterfamilias}

\subsection{Institucionales}

\subsubsection{Profesorado}

\subsection{Flexibilidad}

\chapter{Trabajo en el futuro y conclusiones}

\section{Resumen del trabajo de investigación}

\section{Contribuciones}

\section{Trabajo futuro}

\section{Diseminación}

\index{timetabling!university|see{programación de horarios en universidades}}
\index{timetabling!school|see{calendarización de clases y programación de horarios en escuelas}}
\index{timetabling!course|see{calendarización de cursos}}
\index{timetabling!examination|see{calendarización de exámenes}}

\index{scheduling|see{programación}}
\index{timetabling|see{calendarización}}

\index{schedule|see{programa}}
\index{sequence|see{secuencia}}
\index{timetable|see{horario}}

% Bibliography
\bibliographystyle{apalike_modified}
\bibliography{/Users/harciga/Dropbox/bibliographies/reviewed,/Users/harciga/Dropbox/bibliographies/Dissertation_books}
{
\RaggedRight
\printindex
}
\end{document}
